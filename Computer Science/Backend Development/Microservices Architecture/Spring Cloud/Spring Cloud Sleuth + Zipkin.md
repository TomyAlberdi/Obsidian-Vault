Created: 2024-10-04 19:18
## Family Tree:
1. Computer
2. Backend Development
3. Microservices Architecture
4. [[Spring Cloud]]
-- -
## Observability
With the adoption of distributed architectures—such as microservices—it becomes increasingly difficult to diagnose, debug, and understand errors in production. To address this challenge, the concept of **observability** has emerged. It complements traditional **monitoring**, which involves checking logs and metrics to monitor the health of an application. Observability introduces a new pattern: **Distributed Tracing**. This allows us to monitor a specific request across a system distributed over multiple instances.
There are two key concepts in Distributed Tracing:
- **Tracing ID**: 
  This is used to track an incoming request across all the services involved in fulfilling it. It remains **unique across all service calls**.
- **Span ID**:
  This is an individual identifier for each specific call made within the trace.
Failing to implement distributed tracing makes it impossible to retrieve information about how a request was handled in distributed concurrency environments.
## Spring Cloud Sleuth
**Spring Cloud Sleuth** is a subproject of Spring Cloud and is widely used for **Distributed Tracing**. When implemented in our project, it generates unique identifiers for distributed communications, allowing us to perform individual and grouped analyses from a source application. In other words, Sleuth adds **trace** and **span IDs** to each log. With this implementation, logs will contain four key pieces of information:
1. The name of the application that generated the log.
2. The **trace ID**.
3. The **span ID**.
4. An indicator of whether the log will be synchronized with any external tools.
### Example:
![[Computer Science/Backend Development/Microservices Architecture/Spring Cloud/attachments/image 4.png]]
1. Shows the name of the application that generated the log.
2. Displays the **trace ID**, which remains the same across multiple logs for the same trace.
3. Displays the **span ID**, where a new one is generated for each new request.
4. Indicates whether the log will be synchronized with an external tool.
### Implementation:
First, we need to add the following dependency:
```xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
```
For testing purposes, we'll create a controller that maps two requests. This controller will have two routes: **Path1** will call **Path2** on a fixed port (8090). The idea is to run two separate instances of the same application.
```java
public class Controller {
  private static final Logger logger = LoggerFactory.getLogger(Controller.class);
  private RestTemplate restTemplate;

  @Value("${spring.application.name}")
  private String applicationName;

  public Controller(RestTemplate restTemplate) {
    this.restTemplate = restTemplate;
  }

  @GetMapping("/path1")
  public ResponseEntity<String> path1() {
    logger.info("Request at {} for request /path1 ", applicationName);
    String response = restTemplate.getForObject("http://localhost:8090/service/path2", String.class);
    return ResponseEntity.ok("response from /path1 + " + response);
  }

  @GetMapping("/path2")
  public ResponseEntity<String> path2() {
    logger.info("Request at {} at /path2 ", applicationName);
    return ResponseEntity.ok("response from /path2");
  }
}
```
We need to inject the `RestTemplate` as a bean instead of initializing it directly, so Sleuth can inject headers into the outgoing request. This way, Sleuth adds an interceptor to `RestTemplate` to inject a header with the trace and span identification into the outgoing request.
```java
@Bean
public RestTemplate restTemplate(RestTemplateBuilder builder) {
  return builder.build();
}
```
Starting the two instances:
Once we start the two instances, making a call to `/path1` will demonstrate Distributed Tracing in action.
We will be able to identify:
- The **service name** (shown in the red rectangle),
- The **trace ID** (yellow rectangle),
- The **span ID** (green rectangle).
This shows how Sleuth helps us track the flow of requests across multiple microservices by using unique trace and span IDs, making it easier to monitor and troubleshoot in distributed systems.
## Zipkin
**Zipkin** is a distributed tracing system that, by collecting and analyzing service data, helps resolve latency issues in service-based architectures. It utilizes trace information generated by **Sleuth** to analyze the communication flow between microservices. This allows it to display details about service communication in terms of execution time, success and failure rates, as well as analyze specific calls identified by an **ID**.
If you have a **trace ID** in a log file, you can directly access it. Otherwise, you can query based on attributes like the service, operation name, tags, and duration. Zipkin provides valuable insights, such as the percentage of time spent on a particular service and whether operations succeeded or failed.
### Running Zipkin:
To use this tool, you need to download the executable **jar** from the official website. Once downloaded, you can run it based on its location using the command:
```sh
java -jar zipkin.jar
```
This will start the Zipkin server on port 9411.
### Instrumenting Applications for Zipkin:
Applications need to be instrumented to report trace data to Zipkin. This typically involves configuring a **tracer** or instrumentation library. The most common methods for sending data to Zipkin are through **HTTP** or **Kafka**, but there are many other options, including **Apache ActiveMQ**, **gRPC**, and **RabbitMQ**. The data provided to the user interface can be stored in memory or persistently with a compatible backend such as **Apache Cassandra** or **Elasticsearch**.
### Viewing Dependencies in Zipkin:
By selecting the **dependencies** option within the Zipkin Dashboard, you can visualize the dependencies generated between services that report traceability information to Zipkin. This requires querying data within a specified date range. When selecting one of the involved services, you can view its history of successful and failed calls.