#Development 
So far, we have seen how to handle [[exceptions]] generated by normal program execution. These are situations that occur exceptionally. We also used existing exceptions to protect the integrity of our classes. It would be more convenient to throw appropriate, specific exceptions for the problems that occur. We can do this by applying [[inheritance]].
### Extending `Exceptions`
```java
public class DateException extends Exception {
  public DateException() {
    super();
  }
  
  public DateException(String message) {
    super(message);
  }
  
  @Override
  public String toString() {
    return "The following Exception occurred: " + this.getClass().getName() + "\n" + "Message: " + this.getMessage();
  }
}
```
In this example, we extend `Exception` and create two constructors: one default constructor without parameters and another with a parameter. We then override the `toString` method. The constructor with a parameter can receive a message that will be displayed as detailed error information.
In this example, we extend `Exception`, but you can extend any exception defined in the Java API. It is always advisable to use the exception that is most related to the condition you want to protect.
### Using out custom exception:
```java
public class Date {
  private int day;
  private int month;
  private int year;

  public Date(int d, int m, int y) throws DateException {
    if (d < 1 || d > 31) {
      throw new DateException("Day out of range");
    }
    day = d;
    if (m < 1 || m > 12) {
      throw new DateException("Month out of range");
    }
    month = m;
    year = y;
  }

  public static void main(String[] args) {
    try {
      Date date = new Date(100, -100, 1000);
    }
    catch (DateException exception) {
      System.err.println(exception.getMessage());
    }
  }
}
```
In this example, we use the custom `DateException` to throw specific errors related to invalid day or month values. The `catch` block handles the `DateException` and prints the error message.